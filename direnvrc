# shellcheck shell=bash

REQUIRED_DIRENV_VERSION="2.21.3"

_nix_direnv_preflight () {
  if [[ -z "$direnv" ]]; then
    printf '%s\n' "\$direnv environment variable was not defined. Was this script run inside direnv?"
    exit 1
  fi


  if [[ -z ${NIX_BIN_PREFIX:-} ]]; then
    NIX_BIN_PREFIX=$(command -v nix-shell)
    if [[ -z "${NIX_BIN_PREFIX}" ]]; then
      log_status "nix-direnv: command not found: nix-shell."
      exit 1
    fi
    NIX_BIN_PREFIX="${NIX_BIN_PREFIX%/*}/"
  fi


  if ! has direnv_version || ! direnv_version "$REQUIRED_DIRENV_VERSION" 2>/dev/null; then
    log_status "nix-direnv: base direnv version is older than the required v$REQUIRED_DIRENV_VERSION."
    exit 1
  fi

  nixversion=$("${NIX_BIN_PREFIX}"nix --version)
  [[ "$nixversion" =~ ([0-9]+)[^0-9]*([0-9]+)[^0-9]*([0-9]+)? ]]
  if [[ "${BASH_REMATCH[1]}" -lt "2" || "${BASH_REMATCH[1]}" -eq "2" && "${BASH_REMATCH[2]}" -lt "4" ]]; then
    log_status "nix-direnv: nix version ${BASH_REMATCH[0]} is older than the required 2.4."
    exit 1
  fi

  local layout_dir
  layout_dir=$(direnv_layout_dir)

  if [[ ! -d "$layout_dir/bin" ]]; then
    mkdir -p "$layout_dir/bin"
  fi
  # N.B. This script relies on variable expansion in *this* shell.
  # (i.e. The written out file will have the variables expanded)
  # If the source path changes, the script becomes broken.
  # Because direnv_layout_dir is user controlled,
  # we can't assume to be able to reverse it to get the source dir
  # So there's little to be done about this.
  cat > "${layout_dir}/bin/nix-direnv-reload" <<-EOF
#!/usr/bin/env bash
set -e
if [[ ! -d "$PWD" ]]; then
  echo "Cannot find source directory; Did you move it?"
  echo "(Looking for "$PWD")"
  echo 'Cannot force reload with this script - use "direnv reload" manually and then try again'
  exit 1
fi

# rebuild the cache forcefully
_nix_direnv_force_reload=1 direnv exec "$PWD" true

# Update the mtime for .envrc.
# This will cause direnv to reload again - but without re-building.
touch "$PWD/.envrc"

# Also update the timestamp of whatever profile_rc we have.
# This makes sure that we know we are up to date.
touch -r "$PWD/.envrc" "${layout_dir}"/*.rc
EOF

  if [[ ! -x "${layout_dir}/bin/nix-direnv-reload" ]]; then
    chmod +x "${layout_dir}/bin/nix-direnv-reload"
  fi

  PATH_add "${layout_dir}/bin"
}

# Usage: nix_direnv_version <version_at_least>
#
# Checks that the nix-direnv version is at least as old as <version_at_least>.
nix_direnv_version() {
  declare major='2' minor='4' patch='0' # UPDATE(nix-direnv version)

  [[ $1 =~ ^([^+-.]*)(\.?)([^+-.]*)(\.?)([^+-]*)(-?)([^+]*)(\+?)(.*)$ ]]
  declare -a ver; ver=("${BASH_REMATCH[@]:1}")

  req_major=${ver[0]}
  req_minor=${ver[2]:=0}
  req_patch=${ver[4]:=0}

  if [[ ( ${ver[0]} != +([0-9]) ) \
    || ( ${ver[1]} == '.' && ${ver[2]} != +([0-9]) ) \
    || ( ${ver[3]} == '.' && ${ver[4]} != +([0-9]) ) \
    || ( ${ver[5]} == '-' && ${ver[6]} != +([0-9A-Za-z-])*(.+([0-9A-Za-z-])) ) \
    || ( ${ver[7]} == '+' && ${ver[8]} != +([0-9A-Za-z-])*(.+([0-9A-Za-z-])) ) \
    || ( ( -n ${ver[5]} || -n ${ver[7]} ) && ( -z ${ver[2]} || -z ${ver[4]} ) ) \
  ]]; then
    printf '%s\n' "nix-direnv: error v$1 is not a valid semver version" >&2
    return 1
  fi

  if [[ ($req_major -gt $major) \
     || ($req_major -eq $major && $req_minor -gt $minor) \
     || ($req_major -eq $major && $req_minor -eq $minor && $req_patch -gt $patch)
  ]]; then
    printf '%s\n' "nix-direnv: error current version v$major.$minor.$patch is older than the desired version v$1" >&2
    return 1
  fi
}

_nix_direnv_realpath () {
    if has realpath; then
      realpath "$1"
    else
      perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"
    fi
}

_nix_export_or_unset() {
  local key=$1 value=$2
  if [[ "$value" == __UNSET__ ]]; then
    unset "$key"
  else
    export "$key=$value"
  fi
}

_nix_import_env() {
  local profile_rc=$1

  local old_nix_build_top=${NIX_BUILD_TOP:-__UNSET__}
  local old_tmp=${TMP:-__UNSET__}
  local old_tmpdir=${TMPDIR:-__UNSET__}
  local old_temp=${TEMP:-__UNSET__}
  local old_tempdir=${TEMPDIR:-__UNSET__}
  local old_xdg_data_dirs=${XDG_DATA_DIRS:-}

  # On the first run in manual mode, the profile_rc does not exist.
  if [[ ! -e "$profile_rc" ]]; then
    return
  fi

  eval "$(< "$profile_rc")"
  # `nix print-dev-env` will create a temporary directory and use it as TMPDIR
  # We cannot rely on this directory being available at all times,
  # as it may be garbage collected.
  # Instead - just remove it immediately.
  # Use recursive & force as it may not be empty.
  if [[ -n "${NIX_BUILD_TOP+x}" && "$NIX_BUILD_TOP" == */nix-shell.* && -d "$NIX_BUILD_TOP" ]]; then
    rm -rf "$NIX_BUILD_TOP"
  fi

  _nix_export_or_unset NIX_BUILD_TOP "$old_nix_build_top"
  _nix_export_or_unset TMP "$old_tmp"
  _nix_export_or_unset TMPDIR "$old_tmpdir"
  _nix_export_or_unset TEMP "$old_temp"
  _nix_export_or_unset TEMPDIR "$old_tempdir"
  local new_xdg_data_dirs=${XDG_DATA_DIRS:-}
  export XDG_DATA_DIRS=
  local IFS=:
  for dir in $new_xdg_data_dirs${old_xdg_data_dirs:+:}$old_xdg_data_dirs; do
    dir="${dir%/}" # remove trailing slashes
    if [[ :$XDG_DATA_DIRS: = *:$dir:* ]]; then
      continue # already present, skip
    fi
    XDG_DATA_DIRS="$XDG_DATA_DIRS${XDG_DATA_DIRS:+:}$dir"
  done
}

_nix_add_gcroot() {
  local storepath=$1
  local symlink=$2

  ln -fsn "$storepath" "$symlink"
  nix-store --realise "$storepath" --add-root "$symlink" >/dev/null
}

_nix_clean_old_gcroots() {
  local layout_dir=$1

  rm -rf "$layout_dir/flake-inputs/"
  rm -f "$layout_dir"/{nix,flake}-profile*
}

_nix_argsum_suffix() {
  local out checksum
  if [ -n "$1" ]; then

    if has sha1sum; then
      out=$(sha1sum <<< "$1")
    elif has shasum; then
      out=$(shasum <<< "$1")
    else
      # degrade gracefully both tools are not present
      return
    fi
    read -r checksum _ <<< "$out"
    echo "-$checksum"
  fi
}

nix_direnv_watch_file() {
  # shellcheck disable=2016
  log_error '`nix_direnv_watch_file` is deprecated - use `watch_file`'
  watch_file "$@"
}

# set by nix build - see ./default.nix
JQ=

_jq() {
  if [[ -n $JQ ]]; then
    $JQ "$@"
  elif has jq; then
    jq "$@"
  else
    nix-shell --packages jq --run "$(join_args jq "$@")"
  fi
}

_nix_direnv_watches() {
  local -n _watches=$1
  # allow files under $XDG_DATA_HOME/direnv/allow are filtered out as not relevant
  mapfile -td "" _watches < <(
    # shellcheck disable=2016
    direnv show_dump "${DIRENV_WATCHES}" \
      | _jq --join-output '.[] | select(.Exists ) | .Path | select(. | test($ENV.XDG_DATA_HOME + "/direnv/allow") | not) | (. + "\u0000")'
  )
}

_nix_direnv_manual_reload=0
nix_direnv_manual_reload() {
  _nix_direnv_manual_reload=1
}

use_flake() {
  _nix_direnv_preflight

  flake_expr="${1:-.}"
  flake_dir="${flake_expr%#*}"
  flake_dir=${flake_dir#"path:"}

  if [[ "$flake_expr" = -* ]]; then
    if [[ -n "$2" ]]; then
      log_status "nix-direnv: the first argument must be a flake expression"
    else
      log_status "nix-direnv: the first argument must be a flake expression. did you mean 'use flake . $1'?"
    fi
  fi

  local files_to_watch
  files_to_watch=(".envrc" "$HOME/.direnvrc" "$HOME/.config/direnv/direnvrc")

  if [[ -d "$flake_dir" ]]; then
    files_to_watch+=("$flake_dir/flake.nix" "$flake_dir/flake.lock" "$flake_dir/devshell.toml")
  fi

  watch_file "${files_to_watch[@]}"

  local layout_dir profile
  layout_dir=$(direnv_layout_dir)
  profile="${layout_dir}/flake-profile$(_nix_argsum_suffix "$flake_expr")"
  local profile_rc="${profile}.rc"
  local flake_inputs="${layout_dir}/flake-inputs/"

  local need_update=0
  local watches
  _nix_direnv_watches watches
  local file=
  for file in "${watches[@]}"; do
    if [[ "$file" -nt "$profile_rc" ]]; then
      need_update=1
      break
    fi
  done


  if [[ ! -e "$profile"
     || ! -e "$profile_rc"
     || "$need_update" == "1"
     ]];
  then
    if [[ "$_nix_direnv_manual_reload" == "1" && -z "${_nix_direnv_force_reload-}" ]]; then
      if [[ -e "$profile_rc" ]]; then
        log_error "nix-direnv: cache is out of date. use \"nix-direnv-reload\" to reload"
      else
        log_error "nix-direnv: cache does not exist. use \"nix-direnv-reload\" to create it"
      fi

    else
      _nix_clean_old_gcroots "$layout_dir"

      # We need to update our cache
      local tmp_profile="${layout_dir}/flake-profile.$$"
      local tmp_profile_rc
      tmp_profile_rc=$("${NIX_BIN_PREFIX}nix" print-dev-env \
        --extra-experimental-features "nix-command flakes" \
        --profile "$tmp_profile" "$@")

      local drv
      drv=$(_nix_direnv_realpath "$tmp_profile")

      echo "$tmp_profile_rc" > "$profile_rc"
      rm -f "$tmp_profile" "$tmp_profile"*
      _nix_add_gcroot "$drv" "$profile"

      # also add garbage collection root for source
      local flake_input_paths
      mkdir -p "$flake_inputs"
      flake_input_paths=$("${NIX_BIN_PREFIX}nix" flake archive \
        --json \
        --extra-experimental-features "nix-command flakes" \
        --no-write-lock-file \
        "$flake_dir" | grep -E -o '/nix/store/[^"]+')
      for path in $flake_input_paths; do
        _nix_add_gcroot "$path" "${flake_inputs}/${path##*/}"
      done

      log_status "nix-direnv: renewed cache"
    fi
  else
    # Our cache is valid, use that"
    log_status "nix-direnv: using cached dev shell"

  fi

  _nix_import_env "$profile_rc"
}

use_nix() {
  _nix_direnv_preflight

  local layout_dir path version
  layout_dir=$(direnv_layout_dir)
  path=$("${NIX_BIN_PREFIX}nix-instantiate" --find-file nixpkgs 2>/dev/null || true)
  if [[ -n "$path" ]]; then
    path=$(_nix_direnv_realpath "$path")

    if [[ -f "${path}/.version-suffix" ]]; then
      version=$(< "${path}/.version-suffix")
    elif [[ -f "${path}/.git/HEAD" ]]; then
      local head
      read -r head < "${path}/.git/HEAD"
      local regex="ref: (.*)"
      if [[ "$head" =~  $regex ]]; then
        read -r version < "${path}/.git/${BASH_REMATCH[1]}"
      else
        version="$head"
      fi
    elif [[ -f "${path}/.version" && "${path}" == "/nix/store/"* ]]; then
      # borrow some bits from the store path
      local version_prefix
      read -r version_prefix < <(cat "${path}/.version" ; echo)
      version="${version_prefix}-${path:11:16}"
    fi
  fi

  local profile
  profile="${layout_dir}/nix-profile-${version:-unknown}$(_nix_argsum_suffix "$*")"
  local profile_rc="${profile}.rc"

  local in_packages=0
  local attribute=
  local packages=""
  local extra_args=()

  local nixfile=
  if [[ -e "shell.nix" ]]; then
    nixfile="./shell.nix"
  elif [[ -e "default.nix" ]]; then
    nixfile="./default.nix"
  fi

  while [[ "$#" -gt 0 ]]; do
    i="$1"
    shift

    case $i in
      -p|--packages)
        in_packages=1
        ;;
      --command|--run|--exclude)
        # These commands are unsupported
        # ignore them
        shift
        ;;
      --pure|-i|--keep)
        # These commands are unsupported (but take no argument)
        # ignore them
        ;;
      --include|-I)
        extra_args+=("$i" "$1")
        shift
        ;;
      --attr|-A)
        attribute="$1"
        shift
        ;;
      --option|-o|--arg|--argstr)
        extra_args+=("$i" "$1" "$2")
        shift
        shift
        ;;
      -*)
        # Other arguments are assumed to be of a single arg form
        # (--foo=bar or -j4)
        extra_args+=("$i")
        ;;
      *)
        if [[ $in_packages == 1 ]]; then
          packages+=" $i"
        else
          nixfile=$i
        fi
        ;;
    esac
  done

  watch_file "$HOME/.direnvrc" "$HOME/.config/direnv/direnvrc" ".envrc" "shell.nix" "default.nix"

  local need_update=0
  local watches
  _nix_direnv_watches watches
  local file=
  for file in "${watches[@]}"; do
    if [[ "$file" -nt "$profile_rc" ]]; then
      need_update=1
      break
    fi
  done

  if [[ ! -e "$profile"
     || ! -e "$profile_rc"
     || "$need_update" -eq "1"
     ]];
  then
    if [[ "$_nix_direnv_manual_reload" == "1" && -z "${_nix_direnv_force_reload-}" ]]; then
      if [[ -e "$profile_rc" ]]; then
        log_error "nix-direnv: cache is out of date. use \"nix-direnv-reload\" to reload"
      else
        log_error "nix-direnv: cache does not exist. use \"nix-direnv-reload\" to create it"
      fi
     else
      _nix_clean_old_gcroots "$layout_dir"

      local tmp_profile="${layout_dir}/flake-profile.$$"
      local tmp_profile_rc

      if [[ "$packages" != "" ]]; then
        extra_args+=("--expr" "with import <nixpkgs> {}; mkShell { buildInputs = [ $packages ]; }")
      else
        # figure out what attribute we should build
        if [[ "$attribute" == "" ]]; then
          extra_args+=("--file" "$nixfile")
        else
          extra_args+=("--expr" "(import ${nixfile} {}).${attribute}")
        fi
      fi

      tmp_profile_rc=$("${NIX_BIN_PREFIX}nix" \
                       print-dev-env \
                       --extra-experimental-features "nix-command flakes" \
                       --profile "$tmp_profile" \
                       --impure \
                       "${extra_args[@]}")

      local drv
      drv=$(_nix_direnv_realpath "$tmp_profile")
      echo "$tmp_profile_rc" > "$profile_rc"
      rm -f "$tmp_profile" "$tmp_profile"*
      _nix_add_gcroot "$drv" "$profile"
      log_status "nix-direnv: renewed cache"

    fi
  else
    log_status "nix-direnv: using cached dev shell"
  fi

  _nix_import_env "$profile_rc"


  if [[ "$#" == 0 ]]; then
    watch_file default.nix
    watch_file shell.nix
  fi
}
